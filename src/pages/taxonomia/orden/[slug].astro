---
import Layout from "../../../layouts/Layout.astro";
import Breadcrumb from "../../../components/Breadcrumb.astro";
import RankTag from "../../../components/RankTag.astro";
import { getCollection, getEntry } from "astro:content";
import type { CollectionEntry } from "astro:content";
import { slugify } from "../../../utils/slugify";
import { RANK_LABELS, type Rank } from "../../../utils/rankLabels";

// ---------------------------
// 1) getStaticPaths: generar rutas estáticas solo para órdenes
// ---------------------------
export async function getStaticPaths() {
  const entries = await getCollection("taxonomia");
  return entries
    .filter((entry) => entry.data.rank === "orden")
    .map((entry) => ({
      params: { slug: entry.slug },
    }));
}

// ---------------------------
// 2) Recuperar el slug de la URL
// ---------------------------
const { slug } = Astro.params as { slug: string };

// ---------------------------
// 3) Tipado genérico para el contenido
// ---------------------------
type Taxon = CollectionEntry<"taxonomia">;

// ---------------------------
// 4) Obtener la entrada actual y validar
// ---------------------------
const current = (await getEntry("taxonomia", slug)) as Taxon;
if (!current) {
  throw new Error(`No se encontró el orden: ${slug}`);
}

// ---------------------------
// 5) Renderizar el cuerpo Markdown como componente (<Content />)
//    Esto transforma el cuerpo del archivo .md en HTML.
// Convierte el Markdown en un componente que respeta todos los bloques de código, listas, títulos (#, ##), saltos de línea, etc.
// ---------------------------
const { Content } = await current.render();

// ---------------------------
// 6) Cargar todos los taxones para navegar jerarquía
// ---------------------------
const allTaxa = (await getCollection("taxonomia")) as Taxon[];

// ---------------------------
// 7) Construir la cadena de padres (jerarquía ascendente):
//      buildParentChain slugifica el campo parent al buscar en allTaxa,
//      pasa current y parentChain a <Breadcrumb />
// ---------------------------
function buildParentChain(entry: Taxon): Taxon[] {
  const chain: Taxon[] = [];
  // Partimos de entry.data.parent (nombre “Pinales”, “Pinaceae”, etc.)
  let parentSlug = entry.data.parent ? slugify(entry.data.parent) : null;
  while (parentSlug) {
    const parentEntry = allTaxa.find((t) => t.slug === parentSlug);
    if (!parentEntry) break;
    // Insertamos al inicio para que la jerarquía quede en orden
    chain.unshift(parentEntry);
    // Preparamos el siguiente parentSlug (slugified)
    parentSlug = parentEntry.data.parent
      ? slugify(parentEntry.data.parent)
      : null;
  }
  return chain;
}
const parentChain = buildParentChain(current);

// ---------------------------
// 8) Filtrar hijos directos
// ---------------------------
const children = allTaxa.filter(
  (t) => t.data.parent !== undefined && slugify(t.data.parent) === current.slug
);

// Si este nivel taxonómico tiene hijos, todos compartirán el mismo rank:
const childRank = children[0]?.data.rank as Rank;
const sublevelsLabel = childRank ? RANK_LABELS[childRank].plural : "Subniveles";
---

<Layout title={current.data.name}>
  <!-- Breadcrumb con la jerarquía completa -->
  <Breadcrumb current={current} parents={parentChain} />

  <!-- Título y rango estilizado -->
  <h1>{current.data.name}</h1>
  <RankTag rank={current.data.rank} />

  <!-- Notas (si existen) -->
  {
    current.data.notes && (
      <p>
        <em>{current.data.notes}</em>
      </p>
    )
  }

  <!--  Renderizado real de tu Markdown   -->
  <article>
    <Content />
  </article>

  <!-- Si hubiera hijos (por ejemplo familias), los listamos -->
  {
    children.length > 0 && (
      <>
        <h2>{sublevelsLabel}</h2>
        <ul>
          {children.map((child) => (
            <li>
              <a href={`/taxonomia/${child.data.rank}/${child.slug}`}>
                {child.data.name}
              </a>
            </li>
          ))}
        </ul>
      </>
    )
  }
</Layout>
